---
title: "[C++] Reference"
date: 2020-11-01 

category: C++
toc: true
---

# Reference(참조자)

- C++은 참조자라는 특수한 종류의 변수를 제공한다.
	- 객체 지향의 다형성 개념을 지원하기 위함이라는데, 상속 및 가상 함수, 가상 테이블을 배운 뒤 다시 이해해 보도록 해야겠다.
- 선언 시 타입에 &를 붙여 표현한다.
	- ex) int &a = 변수;
- 변수를 참조하는(가리키는) 목적으로 사용되며, 스택에 저장되는 일반 변수와 달리 별도의 저장 공간을 가지지 않는다.
	- 컴파일러마다 필요 시 메모리를 갖는 경우도 있다고 한다.
- 선언과 동시에 초기화 되어야 하며 한번 초기화 되면 다른 값을 가질 수 없다. 따라서 NULL 값을 가질 수 없다.
- 함수의 인자로 참조자를 전달하면 변수의 복사가 일어나지 않는다.
- 포인터와 동일하게 쓰이지만 다음과 같은 차이가 있다.
	- 멤버 변수에 접근할 때 포인터의 경우'->'를, 참조자의 경우 '.'를 사용한다.
	- 포인터와 달리 참조자는 NULL 값을 가질 수 없다.
- 함수의 매개 변수로 참조자를 사용할 경우 call by reference를 사용할 수 있기 때문에 함수 내에서 변경된 값이 함수 밖에서도 유지된다. 단, call-by-value와 사용법이 같아져 해당 변수가 참조자인지 아닌지 구분하기 어렵다.
- 클래스의 멤버 변수로 참조자를 사용할 경우, const와 마찬가지로 인스턴스 생성과 동시에 초기화가 이루어져야 한다(생성자를 통해).
- 참조자는 변수가 아니기 때문에 리터럴을 대입할 수 없다. 리터럴을 대입하고 싶으면 const로 선언을 해야하며, 이 경우 예외적으로 저장소를 가진다.
	- ```
	  int &a = 10; //compile 오류
	  const int &a = 10; //정상
	  ```
	  
- 일반적으로 **구조체나 클래스**와 같이 크기가 큰 변수를 함수 인자로  전달할 때 많이 사용한다.
	- 일반 변수를 넘길 때는 call-by-value를 이용하는 것이 더 좋다.
- 참조자를 함수의 인수로 사용할 때, 함수 내부에서 값이 바뀌는 것을 원치 않으면 const로 선언하면 된다.
	- ```
	  int MyBook(const Book &book) {..}
	  ```
	- call-by-pointer도 마찬가지이다. pointer로 넘겨 복사가 잃어나지 않게 하는 동시에 const를 사용해 내부에서 값이 수정되지 않도록 할 수 있다.
	
### 예제
	- ```
	  int main() {
	  	Book myBook = new Book("Reference의 이해");
	  	DisplayMyBook(myBook);
	  }
	  
	  void DisplayMyBook(const Book &book) {
	  	std::count << book.titile << std::endl;
	  }
	  ```

	
