---
title: "[C++] Class(1)"
date: 2020-11-01 

category: C++
toc: true
---

## class

- ```
  class 이름 [final] {
	...
  }
  ```
	- final 기호를 붙이면 해당 클래스는 더 이상 상속을 허용하지 않는다.
		
## 상속
- 하위 클래스가 상위 클래스의 모든 변수와 함수를 사용할 수 있게 하는 것으로, 코드의 재사용성을 높인다.
- ': 상위클래스'
	- ```
	  class Child : Parent {
	  	...
      }
	  ```
- 자바와 달리 하나 이상의 클래스를 상속받을 수 있으며 ','로 구분한다.

## 정의
- 일반적으로 선언문과 정의문을 구분하여 사용한다.
	- 선언문은 .h에 정의문은 .cpp
- 함수 멤버의 정의문은 다음과 같은 포맷을 사용한다.
	- ```
	  반환타입 네임스페이스::클래스이름::함수이름(인수) {
			함수 본문
      }
      ```
      
- const 지정자를 사용하여 함수 본문을 정의한다면 멤버 변수에 대한 수정은 허용하지 않는다.
	- ```
	  void print() const;
	  void Person::print() const {
	  	...
	  }
	  ```
	  
- 클래스는 다음과 같은 멤버를 가질 수 있다.
	- 변수와 상수
	- 함수
	- 생성자
	- 소멸자
	- 연산자 오버로딩
	- 사용자 정의
	- 클래스 또는 구조체
	- 사용자가 정의한 데이터 타입
	
## 생성자 
- '지정자 클래스명([인수]) [: 멤버 초기화 리스트] {본문}'
- 객체 생성시(인스턴스화) 메모리에 객체를 위한 공간을 생성한 뒤 생성자를 호출한다. 따라서 생성자는 객체가 메모리 공간에 정상적으로 올라갔음을(객체가 정상적으로 생성됐음을) 알리고 멤벼 변수를 초기화 하는 목적으로 사용된다.
- 사용자가 별도의 생성자를 정의하지 않으면 컴파일러는 인수가 없는 디폴트 생성자를 만든다.
- 멤버 초기화 리스트
	- ```
          int i;

	  Foo(int a) :i(a) {
	  	...
	  }
      ```
    - 생성자의 본문을 호출하기 전에 초기화 작업을 수행한다.
    - 일반 대입과 초기화 리스트를 사용하는 것의 차이는 호출 횟수이다.
    	- 생성자 본문에서 대입시, 멤버 변수를 위한 메모리 공간 마련 후 변수 대입 2번의 호출 횟수가 있다
    	- 반면에 멤버 초기화 리스트를 사용하면 변수의 메모리 공간이 만들어지는 것과 동시에 초기화 작업이 이루어진다.
    	- 따라서 보통 초기화 리스트를 사용하는 방법을 더 선호한다.

## 소멸자
- 객체가 소멸될 때 별도의 작업을 호출하고 싶은 경우 사용한다.
- (필요하다면)사용자가 직접 호출할 수 있는 생성자와 달리, 소멸자는 인위적으로 호출할 수 없고 클래스 소멸시 시스템에서 자동으로 호출한다.
- '지정자 ~클래스명 {본문}
	- '~' : 틸데
	- 지정자는 virtual만 사용 가능
- 생성자와 소멸자 모두 사용자가 호출 시점을 지정할 수 없고, 반환 값 또한 없다.

## this
- 개별 인스턴스의 메모리 주소
- 객체의 멤버 함수를 호출할 때 매개변수를 주지 않아도 자동으로 객체 변수가 매개변수에 포함된다.
	- 이를 **hidden parameter**라고 하며 this로 접근할 수 있다.
	
## 접근 지정자
- 클래스나 구조체는 접근 지정자를 설정하여 객체 내 멤버에 접근할 수 있는 허용 레벨을 정할 수 있다.
- 다음과 같은 종류가 있다.
	- public
	- private
		- 해당 클래스 또는 구조체 내 멤버만 접근 가능
	- protected
		- 해당 클래스 또는 구조체, 이를 상속받은 하위 클래스의 멤버만 접근 가능
- 클래스의 경우 default 접근 지정자는 **private**이다.
	- 구조체의 경우 public
- 클래스와 구조체 멤버의 선언 순서
	- public, protected, private 순으로 나열
	- using, typedef, enum
	- 내부 클래스
	- 멤버 상수와 정적 멤버 변수
	- 생성자
	- 소멸자
	- 멤버 함수와 정적 멤버 변수
	연산자 오버로딩
	- 일반 멤버 변수

## 클래스 vs 구조체
- 클래스와 구조체의 차이점은 다음과 같다.
	- default 접근 지정자의 경우, 클래스는 private 구조체는 public이다.
	- 구조체는 template 타입으로 혀용 X
- 클래스가 구조체를 상속할 수 있으며 역으로도 가능하다.
- 일반적으로 구조체는 함수 위주가 아닌 변수 위주의 멤버를 구성할 떄 우선적으로 사용된다. 또한 int나 long 등의 기본 타입처럼 생성된 객체의 크기가 일정한 데이터를 생성할 떄 사용한다.

## 객체 초기화
- 클래스의 멤버 변수가 public으로 제공이 된다면 클래스 외부 어디에서든 해당 멤버 변수에 접근이 가능하다. 이때 멤버 변수를 수정하면 이 변수에 접근하는 모든 코드를 수정해야 한다.
- 이를 방지하고 코드 유지보수를 용이하게 하기 위해, 멤버변수를 private으로 설정하고 생성자 혹은 별도 함수를 통해 멤버 변수(함수)에 접근하는 방식을 많이 사용한다.
- const로 선언된 클래스의 상수는 원칙적으로 선언과 동시에 초기값을 입력시켜주거나 생성자와 초기화 리스트를 사용하여 초기화 시켜주어야 한다.
- 정적 멤버 변수
	- 정적으로 선언된 변수와 상수는 클래스 외부에서 초기화해야 한다.
	- 정적으로 선언된 상수는 객체 생성 이전에 이미 존재하는 값이기 때문에 생성자를 사용하여 정적 상수를 초기화 할 수 없다.
	- 정적 함수는 객체가 생성되지 않았더라도 호출이 가능하므로 일반 멤버 변수를 사용할 수 없다(**정적 변수만 사용 가능**).
	- 클래스의 변수 선언이 없다 하더라도 정적 변수는 언제든 사용 가능(객체 생성 전 초기화 해주어야 한다)
	- 클래스의 정적 멤버 변수는 모든 클래스의 인스턴스가 공유하는 상수 또는 변수를 만들 때 주로 사용한다.
		- 전역변수랑 같은 것 같은데, 전역변수는 지양되서 그런거같다. 전역변수로 어떤 변수를 쓸 경우 그 변수는 다시 사용할 수 없지만, class에 넣을 경우 class이름::정적변수로 사용을 하니 다른데서도 쓸 수 있을 것 같다.
	- 만약 정적 멤버 함수가 선언과 사용에 있어 특정 클래스에 구속되지 않는다면 네임스페이스 내 전역 함수를 선언하여 사용할 것을 권고한다.

## 인라인 함수와 상수 표현식
- 인라인 함수는 함수를 호출하고 반환값을 받는 대신 인라인함수의 본문을 복사하여 함수 내 문장으로 교체하는 작업을 수행한다.
- 상수표현식(**constexpr**)은 인라인함수와 동일한 기능을 제공한다.
- 상수표현식은 식 자체를 상수와 같은 데이터로 취급하기 때문에 처리속도가 빠르고 적은 메모리를 사용한다.
- 다음과 같은 조건을 만족하지 않으면 사용할 수 없다.
	- constexpr지정자로 선언된 변수는 const처럼 변수를 상수로 만든다. 따라서 해당 값을 수정할 수 없다.
	- constexpr은 함수와 생성자에도 적용 가능하다.
	- constexpr을 함수에 사용하면 인라인 함수로 인식한다.
	- constexpr 지정자로 선언된 함수의 반환 값은 다음만 가능하다.
		- int와 같은 기본타입 혹은 void
		- constexpr 생성자를 가지고 있는 클래스나 구조체
		- 열거형 타입, 포인터, 참조타입
	- constexpr 생성자
		- 다음과 같은 조건을 만족해야 사용할 수 있다.
			1. 클래스는 상위클래스로 추상 클래스를 사용할 수 없다.
			2. 클래스와 베이스클래스 내 존재하는 정적변수를 제외한 모든 멤버 변수는 생성과 동시에 상수나 리터럴을 사용하여 초기화가 이루어져야 한다.
			3. 정적 멤버변수는 생성 이전에 이미 초기화되어있어야 한다.
		- constexpr로 지정된 생성자는 클래스를 단순화시키며, 객체 생성과 동시에 멤벼 변수를 초기화시킬 목적으로 사용한다.
	- constexpr 지정자로 선언한 변수는 상수를 의미
	- constexpr 생성자는 인라인 함수로 인식되므로 일반 객체를 생성하는데 사용하더라도 문제가 되지않는다.
	- constexpr 함수의 인자는 상수여야 한다(변수면 X). 
		- constexpr A(a); <- 여기서 a는 const 혹은 constexpr로 선언되어야 한다.
	- const 지정자는 함수의 본문에 적용하여 클래스 내부 멤버 변수의 수정을 금지하는 기능을 제공한다.
		```
		constexpr std::size_t size() const {return sz;}
		```
	- |const	                 | constexpr             |
	  |----------------------------- |----------------------:|
	  |프로그램 실행시 상수로 인식됨 |컴파일시 상수로 인식됨 |
	  |안전성 확보를 위해 사용       |성능 보장을 위해 용    |
