<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2020-10-24T09:57:00-05:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Yeonjoo’s Blog</title><subtitle>For My Blog</subtitle><author><name>이연주</name></author><entry><title type="html">[TIL] 2020-10-24</title><link href="http://0.0.0.0:4000/2020/10/24/TIL/" rel="alternate" type="text/html" title="[TIL] 2020-10-24" /><published>2020-10-24T00:00:00-05:00</published><updated>2020-10-24T00:00:00-05:00</updated><id>http://0.0.0.0:4000/2020/10/24/TIL</id><content type="html" xml:base="http://0.0.0.0:4000/2020/10/24/TIL/">&lt;ol&gt;
  &lt;li&gt;AF_INET/PF_INET 차이점
    &lt;ul&gt;
      &lt;li&gt;UNP 복습 중, AF_INET과 PF_INET의 차이점이 궁금해 조사였다.&lt;/li&gt;
      &lt;li&gt;AF_INET은 주소 체계 패밀리로, sockaddr_in에서 socket의 주소를 정할 때 설정하는 값이다.&lt;/li&gt;
      &lt;li&gt;PF_INET은 프로토콜 패밀리로, 실제 socket 함수로 연결 방식을 정할 때 설정하는 값이다.&lt;/li&gt;
      &lt;li&gt;AF_INET과 PF_INET은 같은 값을 가진다(#define PF_INET AF_INET). 그럼에도 분리되어 있는 이유는, socket에 대해 처음 설계할 때 한 주소체계가 여러 프로토콜을 사용할 수 있다고 가정하여 확장성을 주고자 했기 때문이다.&lt;/li&gt;
      &lt;li&gt;하지만 현재 위와 같은 일은 일어나지 않고 있다. 즉 구분이 무의미하다. 리눅스 커널 man 페이지도 AF_INET만을 쓸 것을 권장하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Unix Network Programming 복습
    &lt;ul&gt;
      &lt;li&gt;chap 3 socket introduction&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a[10];
memset(a, 5, sizeof(a));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드에서 a[0]의 값은 5일까?
    &lt;ul&gt;
      &lt;li&gt;memset은 무조건 바이트 단위로 값을 채운다.&lt;/li&gt;
      &lt;li&gt;int는 4바이트이므로 a[0]에는 0x05050505가 들어갈 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>이연주</name></author><category term="TIL" /><summary type="html">AF_INET/PF_INET 차이점 UNP 복습 중, AF_INET과 PF_INET의 차이점이 궁금해 조사였다. AF_INET은 주소 체계 패밀리로, sockaddr_in에서 socket의 주소를 정할 때 설정하는 값이다. PF_INET은 프로토콜 패밀리로, 실제 socket 함수로 연결 방식을 정할 때 설정하는 값이다. AF_INET과 PF_INET은 같은 값을 가진다(#define PF_INET AF_INET). 그럼에도 분리되어 있는 이유는, socket에 대해 처음 설계할 때 한 주소체계가 여러 프로토콜을 사용할 수 있다고 가정하여 확장성을 주고자 했기 때문이다. 하지만 현재 위와 같은 일은 일어나지 않고 있다. 즉 구분이 무의미하다. 리눅스 커널 man 페이지도 AF_INET만을 쓸 것을 권장하고 있다.</summary></entry><entry><title type="html">[TIL] 2020-10-23</title><link href="http://0.0.0.0:4000/2020/10/23/TIL/" rel="alternate" type="text/html" title="[TIL] 2020-10-23" /><published>2020-10-23T00:00:00-05:00</published><updated>2020-10-23T00:00:00-05:00</updated><id>http://0.0.0.0:4000/2020/10/23/TIL</id><content type="html" xml:base="http://0.0.0.0:4000/2020/10/23/TIL/">&lt;ol&gt;
  &lt;li&gt;WebServer 개발
    &lt;ul&gt;
      &lt;li&gt;network layer 소스 강화&lt;/li&gt;
      &lt;li&gt;내가 담당 중인 WebServer 제품에서는 epoll, select, devpoll 등이 직접 구현되어 있다. 새롭게 만들 C++ WebServer에서는 직접 구현하기 보다는 boost나 libev등을 써볼 계획이다. 우선 boost에 대해 조사했고, 내일 직접 빌드해서 써보려고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jekyll permalink 수정
    &lt;ul&gt;
      &lt;li&gt;기본 permalink(_config.yaml)가 /:category/:tag/로 되어 있어 post가 정상적으로 노출 되지 않는 문제가 있었다.&lt;/li&gt;
      &lt;li&gt;/:year/:month/:day/:title/로 수정하여 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>이연주</name></author><category term="TIL" /><summary type="html">WebServer 개발 network layer 소스 강화 내가 담당 중인 WebServer 제품에서는 epoll, select, devpoll 등이 직접 구현되어 있다. 새롭게 만들 C++ WebServer에서는 직접 구현하기 보다는 boost나 libev등을 써볼 계획이다. 우선 boost에 대해 조사했고, 내일 직접 빌드해서 써보려고 한다.</summary></entry><entry><title type="html">[TIL] 2020-10-21</title><link href="http://0.0.0.0:4000/2020/10/21/TIL/" rel="alternate" type="text/html" title="[TIL] 2020-10-21" /><published>2020-10-21T00:00:00-05:00</published><updated>2020-10-21T00:00:00-05:00</updated><id>http://0.0.0.0:4000/2020/10/21/TIL</id><content type="html" xml:base="http://0.0.0.0:4000/2020/10/21/TIL/">&lt;ol&gt;
  &lt;li&gt;docker 설치 후 wsl과 연동
    &lt;ul&gt;
      &lt;li&gt;docker에서 jekyll 엔진을 구동하기 위해서는 회사 개발 컴퓨터로 접속해야만 했다.
이제는 WSL을 통해 Windows에서도 docker 사용할 수 있다!&lt;/li&gt;
      &lt;li&gt;docker 설치 후 docker setting에서 WSL 연동할 수 있도록 몇 가지 설정만 하면 되서 매우 편리하다.
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-containers&quot;&gt;microsoft docs&lt;/a&gt;에 방법이 잘 정리되어 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Unix Network Programming 복습
    &lt;ul&gt;
      &lt;li&gt;C++로 WebServer를 만드는 프로젝트를 진행 중이다.&lt;/li&gt;
      &lt;li&gt;Network layer부터 다시 개발하고 있기 때문에 과거 공부하면서 정리했던 UNP를 다시 복습했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>이연주</name></author><category term="TIL" /><summary type="html">docker 설치 후 wsl과 연동 docker에서 jekyll 엔진을 구동하기 위해서는 회사 개발 컴퓨터로 접속해야만 했다. 이제는 WSL을 통해 Windows에서도 docker 사용할 수 있다! docker 설치 후 docker setting에서 WSL 연동할 수 있도록 몇 가지 설정만 하면 되서 매우 편리하다. microsoft docs에 방법이 잘 정리되어 있다.</summary></entry><entry><title type="html">[TIL] 2020-10-20</title><link href="http://0.0.0.0:4000/2020/10/20/TIL/" rel="alternate" type="text/html" title="[TIL] 2020-10-20" /><published>2020-10-20T00:00:00-05:00</published><updated>2020-10-20T00:00:00-05:00</updated><id>http://0.0.0.0:4000/2020/10/20/TIL</id><content type="html" xml:base="http://0.0.0.0:4000/2020/10/20/TIL/">&lt;ol&gt;
  &lt;li&gt;CLion에서 github 연동
    &lt;ul&gt;
      &lt;li&gt;WSL
        &lt;ul&gt;
          &lt;li&gt;형상 관리를 위해 CLion과 Git을 연동했다. Git을 직접 설치한 후 경로를 잡아도 되지만, WSL을 이용하면 CLion에서 자동으로 WSL에 설치된 git path를 잡는다고 한다.&lt;/li&gt;
          &lt;li&gt;WSL 정리 -&amp;gt; 추후 페이지 추가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CLion에서 git 사용
        &lt;ul&gt;
          &lt;li&gt;Alt + `&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>이연주</name></author><category term="TIL" /><summary type="html">CLion에서 github 연동 WSL 형상 관리를 위해 CLion과 Git을 연동했다. Git을 직접 설치한 후 경로를 잡아도 되지만, WSL을 이용하면 CLion에서 자동으로 WSL에 설치된 git path를 잡는다고 한다. WSL 정리 -&amp;gt; 추후 페이지 추가 CLion에서 git 사용 Alt + `</summary></entry><entry><title type="html">[TIL] 2020-10-19</title><link href="http://0.0.0.0:4000/2020/10/19/TIL/" rel="alternate" type="text/html" title="[TIL] 2020-10-19" /><published>2020-10-19T00:00:00-05:00</published><updated>2020-10-19T00:00:00-05:00</updated><id>http://0.0.0.0:4000/2020/10/19/TIL</id><content type="html" xml:base="http://0.0.0.0:4000/2020/10/19/TIL/">&lt;ol&gt;
  &lt;li&gt;github blog 생성
    &lt;ul&gt;
      &lt;li&gt;jekyll 적용&lt;/li&gt;
      &lt;li&gt;docker로 test 환경 구축&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;docker run –rm –volume=”$PWD:/srv/jekyll” –privileged -p 4000:4000 -it jekyll/jekyll /bin/bash
    jekyll serve
        &lt;ul&gt;
          &lt;li&gt;접속할 수 있는 주소를 출력해주면 해당 url로 접속하여 테스트 후 push
            &lt;ul&gt;
              &lt;li&gt;docker로 테스트 환경 구축하면 매우 편리&lt;/li&gt;
              &lt;li&gt;github은 내장하고 있는 ruby 엔진을 통해 로딩&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>이연주</name></author><category term="TIL" /><summary type="html">github blog 생성 jekyll 적용 docker로 test 환경 구축 docker run –rm –volume=”$PWD:/srv/jekyll” –privileged -p 4000:4000 -it jekyll/jekyll /bin/bash jekyll serve 접속할 수 있는 주소를 출력해주면 해당 url로 접속하여 테스트 후 push docker로 테스트 환경 구축하면 매우 편리 github은 내장하고 있는 ruby 엔진을 통해 로딩</summary></entry></feed>